// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PREFAB_LIQUID_SCHEMAS_ASSET_H_
#define FLATBUFFERS_GENERATED_PREFAB_LIQUID_SCHEMAS_ASSET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "Base.schema.h"

namespace liquid {
namespace schemas {
namespace asset {

struct EntityName;
struct EntityNameBuilder;

struct EntityTransform;

struct EntityAsset;

struct EntityPointLight;

struct EntityDirectionalLight;

struct Prefab;
struct PrefabBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityTransform FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t entity_;
  liquid::schemas::base::Vec3 position_;
  liquid::schemas::base::Quat rotation_;
  liquid::schemas::base::Vec3 scale_;
  int32_t parent_;

 public:
  EntityTransform()
      : entity_(0),
        position_(),
        rotation_(),
        scale_(),
        parent_(0) {
  }
  EntityTransform(uint32_t _entity, const liquid::schemas::base::Vec3 &_position, const liquid::schemas::base::Quat &_rotation, const liquid::schemas::base::Vec3 &_scale, int32_t _parent)
      : entity_(::flatbuffers::EndianScalar(_entity)),
        position_(_position),
        rotation_(_rotation),
        scale_(_scale),
        parent_(::flatbuffers::EndianScalar(_parent)) {
  }
  uint32_t entity() const {
    return ::flatbuffers::EndianScalar(entity_);
  }
  const liquid::schemas::base::Vec3 &position() const {
    return position_;
  }
  const liquid::schemas::base::Quat &rotation() const {
    return rotation_;
  }
  const liquid::schemas::base::Vec3 &scale() const {
    return scale_;
  }
  int32_t parent() const {
    return ::flatbuffers::EndianScalar(parent_);
  }
};
FLATBUFFERS_STRUCT_END(EntityTransform, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityAsset FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t entity_;
  uint32_t asset_;

 public:
  EntityAsset()
      : entity_(0),
        asset_(0) {
  }
  EntityAsset(uint32_t _entity, uint32_t _asset)
      : entity_(::flatbuffers::EndianScalar(_entity)),
        asset_(::flatbuffers::EndianScalar(_asset)) {
  }
  uint32_t entity() const {
    return ::flatbuffers::EndianScalar(entity_);
  }
  uint32_t asset() const {
    return ::flatbuffers::EndianScalar(asset_);
  }
};
FLATBUFFERS_STRUCT_END(EntityAsset, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityPointLight FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t entity_;
  liquid::schemas::base::Vec4 color_;
  float intensity_;
  float range_;

 public:
  EntityPointLight()
      : entity_(0),
        color_(),
        intensity_(0),
        range_(0) {
  }
  EntityPointLight(uint32_t _entity, const liquid::schemas::base::Vec4 &_color, float _intensity, float _range)
      : entity_(::flatbuffers::EndianScalar(_entity)),
        color_(_color),
        intensity_(::flatbuffers::EndianScalar(_intensity)),
        range_(::flatbuffers::EndianScalar(_range)) {
  }
  uint32_t entity() const {
    return ::flatbuffers::EndianScalar(entity_);
  }
  const liquid::schemas::base::Vec4 &color() const {
    return color_;
  }
  float intensity() const {
    return ::flatbuffers::EndianScalar(intensity_);
  }
  float range() const {
    return ::flatbuffers::EndianScalar(range_);
  }
};
FLATBUFFERS_STRUCT_END(EntityPointLight, 28);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EntityDirectionalLight FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t entity_;
  liquid::schemas::base::Vec4 color_;
  float intensity_;
  liquid::schemas::base::Vec3 direction_;

 public:
  EntityDirectionalLight()
      : entity_(0),
        color_(),
        intensity_(0),
        direction_() {
  }
  EntityDirectionalLight(uint32_t _entity, const liquid::schemas::base::Vec4 &_color, float _intensity, const liquid::schemas::base::Vec3 &_direction)
      : entity_(::flatbuffers::EndianScalar(_entity)),
        color_(_color),
        intensity_(::flatbuffers::EndianScalar(_intensity)),
        direction_(_direction) {
  }
  uint32_t entity() const {
    return ::flatbuffers::EndianScalar(entity_);
  }
  const liquid::schemas::base::Vec4 &color() const {
    return color_;
  }
  float intensity() const {
    return ::flatbuffers::EndianScalar(intensity_);
  }
  const liquid::schemas::base::Vec3 &direction() const {
    return direction_;
  }
};
FLATBUFFERS_STRUCT_END(EntityDirectionalLight, 36);

struct EntityName FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EntityNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITY = 4,
    VT_NAME = 6
  };
  uint32_t entity() const {
    return GetField<uint32_t>(VT_ENTITY, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ENTITY, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct EntityNameBuilder {
  typedef EntityName Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entity(uint32_t entity) {
    fbb_.AddElement<uint32_t>(EntityName::VT_ENTITY, entity, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(EntityName::VT_NAME, name);
  }
  explicit EntityNameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EntityName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EntityName>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EntityName> CreateEntityName(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t entity = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  EntityNameBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_entity(entity);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EntityName> CreateEntityNameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t entity = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return liquid::schemas::asset::CreateEntityName(
      _fbb,
      entity,
      name__);
}

struct Prefab FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PrefabBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ASSETS = 4,
    VT_NAMES = 6,
    VT_TRANSFORMS = 8,
    VT_MESHES = 10,
    VT_MATERIALS = 12,
    VT_SKELETONS = 14,
    VT_ANIMATIONS = 16,
    VT_ANIMATORS = 18,
    VT_POINT_LIGHTS = 20,
    VT_DIRECTIONAL_LIGHTS = 22
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *assets() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ASSETS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::EntityName>> *names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::EntityName>> *>(VT_NAMES);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityTransform *> *transforms() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityTransform *> *>(VT_TRANSFORMS);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *meshes() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *>(VT_MESHES);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *materials() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *>(VT_MATERIALS);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *skeletons() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *>(VT_SKELETONS);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *animations() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *>(VT_ANIMATIONS);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *animators() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *> *>(VT_ANIMATORS);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityPointLight *> *point_lights() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityPointLight *> *>(VT_POINT_LIGHTS);
  }
  const ::flatbuffers::Vector<const liquid::schemas::asset::EntityDirectionalLight *> *directional_lights() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::asset::EntityDirectionalLight *> *>(VT_DIRECTIONAL_LIGHTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ASSETS) &&
           verifier.VerifyVector(assets()) &&
           verifier.VerifyVectorOfStrings(assets()) &&
           VerifyOffsetRequired(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfTables(names()) &&
           VerifyOffsetRequired(verifier, VT_TRANSFORMS) &&
           verifier.VerifyVector(transforms()) &&
           VerifyOffsetRequired(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           VerifyOffsetRequired(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           VerifyOffsetRequired(verifier, VT_SKELETONS) &&
           verifier.VerifyVector(skeletons()) &&
           VerifyOffsetRequired(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           VerifyOffsetRequired(verifier, VT_ANIMATORS) &&
           verifier.VerifyVector(animators()) &&
           VerifyOffsetRequired(verifier, VT_POINT_LIGHTS) &&
           verifier.VerifyVector(point_lights()) &&
           VerifyOffsetRequired(verifier, VT_DIRECTIONAL_LIGHTS) &&
           verifier.VerifyVector(directional_lights()) &&
           verifier.EndTable();
  }
};

struct PrefabBuilder {
  typedef Prefab Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_assets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> assets) {
    fbb_.AddOffset(Prefab::VT_ASSETS, assets);
  }
  void add_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::EntityName>>> names) {
    fbb_.AddOffset(Prefab::VT_NAMES, names);
  }
  void add_transforms(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityTransform *>> transforms) {
    fbb_.AddOffset(Prefab::VT_TRANSFORMS, transforms);
  }
  void add_meshes(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> meshes) {
    fbb_.AddOffset(Prefab::VT_MESHES, meshes);
  }
  void add_materials(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> materials) {
    fbb_.AddOffset(Prefab::VT_MATERIALS, materials);
  }
  void add_skeletons(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> skeletons) {
    fbb_.AddOffset(Prefab::VT_SKELETONS, skeletons);
  }
  void add_animations(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> animations) {
    fbb_.AddOffset(Prefab::VT_ANIMATIONS, animations);
  }
  void add_animators(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> animators) {
    fbb_.AddOffset(Prefab::VT_ANIMATORS, animators);
  }
  void add_point_lights(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityPointLight *>> point_lights) {
    fbb_.AddOffset(Prefab::VT_POINT_LIGHTS, point_lights);
  }
  void add_directional_lights(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityDirectionalLight *>> directional_lights) {
    fbb_.AddOffset(Prefab::VT_DIRECTIONAL_LIGHTS, directional_lights);
  }
  explicit PrefabBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Prefab> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Prefab>(end);
    fbb_.Required(o, Prefab::VT_ASSETS);
    fbb_.Required(o, Prefab::VT_NAMES);
    fbb_.Required(o, Prefab::VT_TRANSFORMS);
    fbb_.Required(o, Prefab::VT_MESHES);
    fbb_.Required(o, Prefab::VT_MATERIALS);
    fbb_.Required(o, Prefab::VT_SKELETONS);
    fbb_.Required(o, Prefab::VT_ANIMATIONS);
    fbb_.Required(o, Prefab::VT_ANIMATORS);
    fbb_.Required(o, Prefab::VT_POINT_LIGHTS);
    fbb_.Required(o, Prefab::VT_DIRECTIONAL_LIGHTS);
    return o;
  }
};

inline ::flatbuffers::Offset<Prefab> CreatePrefab(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> assets = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::EntityName>>> names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityTransform *>> transforms = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> meshes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> materials = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> skeletons = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> animations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityAsset *>> animators = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityPointLight *>> point_lights = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::asset::EntityDirectionalLight *>> directional_lights = 0) {
  PrefabBuilder builder_(_fbb);
  builder_.add_directional_lights(directional_lights);
  builder_.add_point_lights(point_lights);
  builder_.add_animators(animators);
  builder_.add_animations(animations);
  builder_.add_skeletons(skeletons);
  builder_.add_materials(materials);
  builder_.add_meshes(meshes);
  builder_.add_transforms(transforms);
  builder_.add_names(names);
  builder_.add_assets(assets);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Prefab> CreatePrefabDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *assets = nullptr,
    const std::vector<::flatbuffers::Offset<liquid::schemas::asset::EntityName>> *names = nullptr,
    const std::vector<liquid::schemas::asset::EntityTransform> *transforms = nullptr,
    const std::vector<liquid::schemas::asset::EntityAsset> *meshes = nullptr,
    const std::vector<liquid::schemas::asset::EntityAsset> *materials = nullptr,
    const std::vector<liquid::schemas::asset::EntityAsset> *skeletons = nullptr,
    const std::vector<liquid::schemas::asset::EntityAsset> *animations = nullptr,
    const std::vector<liquid::schemas::asset::EntityAsset> *animators = nullptr,
    const std::vector<liquid::schemas::asset::EntityPointLight> *point_lights = nullptr,
    const std::vector<liquid::schemas::asset::EntityDirectionalLight> *directional_lights = nullptr) {
  auto assets__ = assets ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*assets) : 0;
  auto names__ = names ? _fbb.CreateVector<::flatbuffers::Offset<liquid::schemas::asset::EntityName>>(*names) : 0;
  auto transforms__ = transforms ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityTransform>(*transforms) : 0;
  auto meshes__ = meshes ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityAsset>(*meshes) : 0;
  auto materials__ = materials ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityAsset>(*materials) : 0;
  auto skeletons__ = skeletons ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityAsset>(*skeletons) : 0;
  auto animations__ = animations ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityAsset>(*animations) : 0;
  auto animators__ = animators ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityAsset>(*animators) : 0;
  auto point_lights__ = point_lights ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityPointLight>(*point_lights) : 0;
  auto directional_lights__ = directional_lights ? _fbb.CreateVectorOfStructs<liquid::schemas::asset::EntityDirectionalLight>(*directional_lights) : 0;
  return liquid::schemas::asset::CreatePrefab(
      _fbb,
      assets__,
      names__,
      transforms__,
      meshes__,
      materials__,
      skeletons__,
      animations__,
      animators__,
      point_lights__,
      directional_lights__);
}

inline const liquid::schemas::asset::Prefab *GetPrefab(const void *buf) {
  return ::flatbuffers::GetRoot<liquid::schemas::asset::Prefab>(buf);
}

inline const liquid::schemas::asset::Prefab *GetSizePrefixedPrefab(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<liquid::schemas::asset::Prefab>(buf);
}

inline const char *PrefabIdentifier() {
  return "LPFB";
}

inline bool PrefabBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PrefabIdentifier());
}

inline bool SizePrefixedPrefabBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PrefabIdentifier(), true);
}

inline bool VerifyPrefabBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<liquid::schemas::asset::Prefab>(PrefabIdentifier());
}

inline bool VerifySizePrefixedPrefabBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<liquid::schemas::asset::Prefab>(PrefabIdentifier());
}

inline void FinishPrefabBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<liquid::schemas::asset::Prefab> root) {
  fbb.Finish(root, PrefabIdentifier());
}

inline void FinishSizePrefixedPrefabBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<liquid::schemas::asset::Prefab> root) {
  fbb.FinishSizePrefixed(root, PrefabIdentifier());
}

}  // namespace asset
}  // namespace schemas
}  // namespace liquid

#endif  // FLATBUFFERS_GENERATED_PREFAB_LIQUID_SCHEMAS_ASSET_H_
