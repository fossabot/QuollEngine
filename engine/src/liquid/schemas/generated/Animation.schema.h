// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMATION_LIQUID_SCHEMAS_ASSET_H_
#define FLATBUFFERS_GENERATED_ANIMATION_LIQUID_SCHEMAS_ASSET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "Base.schema.h"

namespace liquid {
namespace schemas {
namespace asset {

struct KeyframePositionValues;
struct KeyframePositionValuesBuilder;

struct KeyframeRotationValues;
struct KeyframeRotationValuesBuilder;

struct KeyframeScaleValues;
struct KeyframeScaleValuesBuilder;

struct Keyframe;
struct KeyframeBuilder;

struct Animation;
struct AnimationBuilder;

enum KeyframeInterpolation : uint8_t {
  KeyframeInterpolation_Step = 0,
  KeyframeInterpolation_Linear = 1,
  KeyframeInterpolation_MIN = KeyframeInterpolation_Step,
  KeyframeInterpolation_MAX = KeyframeInterpolation_Linear
};

inline const KeyframeInterpolation (&EnumValuesKeyframeInterpolation())[2] {
  static const KeyframeInterpolation values[] = {
    KeyframeInterpolation_Step,
    KeyframeInterpolation_Linear
  };
  return values;
}

inline const char * const *EnumNamesKeyframeInterpolation() {
  static const char * const names[3] = {
    "Step",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyframeInterpolation(KeyframeInterpolation e) {
  if (::flatbuffers::IsOutRange(e, KeyframeInterpolation_Step, KeyframeInterpolation_Linear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyframeInterpolation()[index];
}

enum KeyframeValues : uint8_t {
  KeyframeValues_NONE = 0,
  KeyframeValues_KeyframePositionValues = 1,
  KeyframeValues_KeyframeRotationValues = 2,
  KeyframeValues_KeyframeScaleValues = 3,
  KeyframeValues_MIN = KeyframeValues_NONE,
  KeyframeValues_MAX = KeyframeValues_KeyframeScaleValues
};

inline const KeyframeValues (&EnumValuesKeyframeValues())[4] {
  static const KeyframeValues values[] = {
    KeyframeValues_NONE,
    KeyframeValues_KeyframePositionValues,
    KeyframeValues_KeyframeRotationValues,
    KeyframeValues_KeyframeScaleValues
  };
  return values;
}

inline const char * const *EnumNamesKeyframeValues() {
  static const char * const names[5] = {
    "NONE",
    "KeyframePositionValues",
    "KeyframeRotationValues",
    "KeyframeScaleValues",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyframeValues(KeyframeValues e) {
  if (::flatbuffers::IsOutRange(e, KeyframeValues_NONE, KeyframeValues_KeyframeScaleValues)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyframeValues()[index];
}

template<typename T> struct KeyframeValuesTraits {
  static const KeyframeValues enum_value = KeyframeValues_NONE;
};

template<> struct KeyframeValuesTraits<liquid::schemas::asset::KeyframePositionValues> {
  static const KeyframeValues enum_value = KeyframeValues_KeyframePositionValues;
};

template<> struct KeyframeValuesTraits<liquid::schemas::asset::KeyframeRotationValues> {
  static const KeyframeValues enum_value = KeyframeValues_KeyframeRotationValues;
};

template<> struct KeyframeValuesTraits<liquid::schemas::asset::KeyframeScaleValues> {
  static const KeyframeValues enum_value = KeyframeValues_KeyframeScaleValues;
};

bool VerifyKeyframeValues(::flatbuffers::Verifier &verifier, const void *obj, KeyframeValues type);
bool VerifyKeyframeValuesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct KeyframePositionValues FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyframePositionValuesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<const liquid::schemas::base::Vec4 *> *data() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::base::Vec4 *> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct KeyframePositionValuesBuilder {
  typedef KeyframePositionValues Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::base::Vec4 *>> data) {
    fbb_.AddOffset(KeyframePositionValues::VT_DATA, data);
  }
  explicit KeyframePositionValuesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyframePositionValues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyframePositionValues>(end);
    fbb_.Required(o, KeyframePositionValues::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyframePositionValues> CreateKeyframePositionValues(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::base::Vec4 *>> data = 0) {
  KeyframePositionValuesBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyframePositionValues> CreateKeyframePositionValuesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<liquid::schemas::base::Vec4> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVectorOfStructs<liquid::schemas::base::Vec4>(*data) : 0;
  return liquid::schemas::asset::CreateKeyframePositionValues(
      _fbb,
      data__);
}

struct KeyframeRotationValues FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyframeRotationValuesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<const liquid::schemas::base::Vec4 *> *data() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::base::Vec4 *> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct KeyframeRotationValuesBuilder {
  typedef KeyframeRotationValues Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::base::Vec4 *>> data) {
    fbb_.AddOffset(KeyframeRotationValues::VT_DATA, data);
  }
  explicit KeyframeRotationValuesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyframeRotationValues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyframeRotationValues>(end);
    fbb_.Required(o, KeyframeRotationValues::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyframeRotationValues> CreateKeyframeRotationValues(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::base::Vec4 *>> data = 0) {
  KeyframeRotationValuesBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyframeRotationValues> CreateKeyframeRotationValuesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<liquid::schemas::base::Vec4> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVectorOfStructs<liquid::schemas::base::Vec4>(*data) : 0;
  return liquid::schemas::asset::CreateKeyframeRotationValues(
      _fbb,
      data__);
}

struct KeyframeScaleValues FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyframeScaleValuesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<const liquid::schemas::base::Vec4 *> *data() const {
    return GetPointer<const ::flatbuffers::Vector<const liquid::schemas::base::Vec4 *> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct KeyframeScaleValuesBuilder {
  typedef KeyframeScaleValues Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::base::Vec4 *>> data) {
    fbb_.AddOffset(KeyframeScaleValues::VT_DATA, data);
  }
  explicit KeyframeScaleValuesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyframeScaleValues> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyframeScaleValues>(end);
    fbb_.Required(o, KeyframeScaleValues::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyframeScaleValues> CreateKeyframeScaleValues(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const liquid::schemas::base::Vec4 *>> data = 0) {
  KeyframeScaleValuesBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyframeScaleValues> CreateKeyframeScaleValuesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<liquid::schemas::base::Vec4> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVectorOfStructs<liquid::schemas::base::Vec4>(*data) : 0;
  return liquid::schemas::asset::CreateKeyframeScaleValues(
      _fbb,
      data__);
}

struct Keyframe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyframeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMES = 4,
    VT_VALUES_TYPE = 6,
    VT_VALUES = 8,
    VT_INTERPOLATION = 10,
    VT_JOINT_TARGET = 12,
    VT_JOINT = 14
  };
  const ::flatbuffers::Vector<float> *times() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TIMES);
  }
  liquid::schemas::asset::KeyframeValues values_type() const {
    return static_cast<liquid::schemas::asset::KeyframeValues>(GetField<uint8_t>(VT_VALUES_TYPE, 0));
  }
  const void *values() const {
    return GetPointer<const void *>(VT_VALUES);
  }
  template<typename T> const T *values_as() const;
  const liquid::schemas::asset::KeyframePositionValues *values_as_KeyframePositionValues() const {
    return values_type() == liquid::schemas::asset::KeyframeValues_KeyframePositionValues ? static_cast<const liquid::schemas::asset::KeyframePositionValues *>(values()) : nullptr;
  }
  const liquid::schemas::asset::KeyframeRotationValues *values_as_KeyframeRotationValues() const {
    return values_type() == liquid::schemas::asset::KeyframeValues_KeyframeRotationValues ? static_cast<const liquid::schemas::asset::KeyframeRotationValues *>(values()) : nullptr;
  }
  const liquid::schemas::asset::KeyframeScaleValues *values_as_KeyframeScaleValues() const {
    return values_type() == liquid::schemas::asset::KeyframeValues_KeyframeScaleValues ? static_cast<const liquid::schemas::asset::KeyframeScaleValues *>(values()) : nullptr;
  }
  liquid::schemas::asset::KeyframeInterpolation interpolation() const {
    return static_cast<liquid::schemas::asset::KeyframeInterpolation>(GetField<uint8_t>(VT_INTERPOLATION, 0));
  }
  bool joint_target() const {
    return GetField<uint8_t>(VT_JOINT_TARGET, 0) != 0;
  }
  uint8_t joint() const {
    return GetField<uint8_t>(VT_JOINT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TIMES) &&
           verifier.VerifyVector(times()) &&
           VerifyField<uint8_t>(verifier, VT_VALUES_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUES) &&
           VerifyKeyframeValues(verifier, values(), values_type()) &&
           VerifyField<uint8_t>(verifier, VT_INTERPOLATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_JOINT_TARGET, 1) &&
           VerifyField<uint8_t>(verifier, VT_JOINT, 1) &&
           verifier.EndTable();
  }
};

template<> inline const liquid::schemas::asset::KeyframePositionValues *Keyframe::values_as<liquid::schemas::asset::KeyframePositionValues>() const {
  return values_as_KeyframePositionValues();
}

template<> inline const liquid::schemas::asset::KeyframeRotationValues *Keyframe::values_as<liquid::schemas::asset::KeyframeRotationValues>() const {
  return values_as_KeyframeRotationValues();
}

template<> inline const liquid::schemas::asset::KeyframeScaleValues *Keyframe::values_as<liquid::schemas::asset::KeyframeScaleValues>() const {
  return values_as_KeyframeScaleValues();
}

struct KeyframeBuilder {
  typedef Keyframe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_times(::flatbuffers::Offset<::flatbuffers::Vector<float>> times) {
    fbb_.AddOffset(Keyframe::VT_TIMES, times);
  }
  void add_values_type(liquid::schemas::asset::KeyframeValues values_type) {
    fbb_.AddElement<uint8_t>(Keyframe::VT_VALUES_TYPE, static_cast<uint8_t>(values_type), 0);
  }
  void add_values(::flatbuffers::Offset<void> values) {
    fbb_.AddOffset(Keyframe::VT_VALUES, values);
  }
  void add_interpolation(liquid::schemas::asset::KeyframeInterpolation interpolation) {
    fbb_.AddElement<uint8_t>(Keyframe::VT_INTERPOLATION, static_cast<uint8_t>(interpolation), 0);
  }
  void add_joint_target(bool joint_target) {
    fbb_.AddElement<uint8_t>(Keyframe::VT_JOINT_TARGET, static_cast<uint8_t>(joint_target), 0);
  }
  void add_joint(uint8_t joint) {
    fbb_.AddElement<uint8_t>(Keyframe::VT_JOINT, joint, 0);
  }
  explicit KeyframeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Keyframe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Keyframe>(end);
    fbb_.Required(o, Keyframe::VT_TIMES);
    return o;
  }
};

inline ::flatbuffers::Offset<Keyframe> CreateKeyframe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> times = 0,
    liquid::schemas::asset::KeyframeValues values_type = liquid::schemas::asset::KeyframeValues_NONE,
    ::flatbuffers::Offset<void> values = 0,
    liquid::schemas::asset::KeyframeInterpolation interpolation = liquid::schemas::asset::KeyframeInterpolation_Step,
    bool joint_target = false,
    uint8_t joint = 0) {
  KeyframeBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_times(times);
  builder_.add_joint(joint);
  builder_.add_joint_target(joint_target);
  builder_.add_interpolation(interpolation);
  builder_.add_values_type(values_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Keyframe> CreateKeyframeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *times = nullptr,
    liquid::schemas::asset::KeyframeValues values_type = liquid::schemas::asset::KeyframeValues_NONE,
    ::flatbuffers::Offset<void> values = 0,
    liquid::schemas::asset::KeyframeInterpolation interpolation = liquid::schemas::asset::KeyframeInterpolation_Step,
    bool joint_target = false,
    uint8_t joint = 0) {
  auto times__ = times ? _fbb.CreateVector<float>(*times) : 0;
  return liquid::schemas::asset::CreateKeyframe(
      _fbb,
      times__,
      values_type,
      values,
      interpolation,
      joint_target,
      joint);
}

struct Animation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_KEYFRAMES = 6
  };
  float time() const {
    return GetField<float>(VT_TIME, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::Keyframe>> *keyframes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::Keyframe>> *>(VT_KEYFRAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIME, 4) &&
           VerifyOffsetRequired(verifier, VT_KEYFRAMES) &&
           verifier.VerifyVector(keyframes()) &&
           verifier.VerifyVectorOfTables(keyframes()) &&
           verifier.EndTable();
  }
};

struct AnimationBuilder {
  typedef Animation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(float time) {
    fbb_.AddElement<float>(Animation::VT_TIME, time, 0.0f);
  }
  void add_keyframes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::Keyframe>>> keyframes) {
    fbb_.AddOffset(Animation::VT_KEYFRAMES, keyframes);
  }
  explicit AnimationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Animation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Animation>(end);
    fbb_.Required(o, Animation::VT_KEYFRAMES);
    return o;
  }
};

inline ::flatbuffers::Offset<Animation> CreateAnimation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<liquid::schemas::asset::Keyframe>>> keyframes = 0) {
  AnimationBuilder builder_(_fbb);
  builder_.add_keyframes(keyframes);
  builder_.add_time(time);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Animation> CreateAnimationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float time = 0.0f,
    const std::vector<::flatbuffers::Offset<liquid::schemas::asset::Keyframe>> *keyframes = nullptr) {
  auto keyframes__ = keyframes ? _fbb.CreateVector<::flatbuffers::Offset<liquid::schemas::asset::Keyframe>>(*keyframes) : 0;
  return liquid::schemas::asset::CreateAnimation(
      _fbb,
      time,
      keyframes__);
}

inline bool VerifyKeyframeValues(::flatbuffers::Verifier &verifier, const void *obj, KeyframeValues type) {
  switch (type) {
    case KeyframeValues_NONE: {
      return true;
    }
    case KeyframeValues_KeyframePositionValues: {
      auto ptr = reinterpret_cast<const liquid::schemas::asset::KeyframePositionValues *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KeyframeValues_KeyframeRotationValues: {
      auto ptr = reinterpret_cast<const liquid::schemas::asset::KeyframeRotationValues *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case KeyframeValues_KeyframeScaleValues: {
      auto ptr = reinterpret_cast<const liquid::schemas::asset::KeyframeScaleValues *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyKeyframeValuesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyKeyframeValues(
        verifier,  values->Get(i), types->GetEnum<KeyframeValues>(i))) {
      return false;
    }
  }
  return true;
}

inline const liquid::schemas::asset::Animation *GetAnimation(const void *buf) {
  return ::flatbuffers::GetRoot<liquid::schemas::asset::Animation>(buf);
}

inline const liquid::schemas::asset::Animation *GetSizePrefixedAnimation(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<liquid::schemas::asset::Animation>(buf);
}

inline const char *AnimationIdentifier() {
  return "LANM";
}

inline bool AnimationBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AnimationIdentifier());
}

inline bool SizePrefixedAnimationBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AnimationIdentifier(), true);
}

inline bool VerifyAnimationBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<liquid::schemas::asset::Animation>(AnimationIdentifier());
}

inline bool VerifySizePrefixedAnimationBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<liquid::schemas::asset::Animation>(AnimationIdentifier());
}

inline void FinishAnimationBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<liquid::schemas::asset::Animation> root) {
  fbb.Finish(root, AnimationIdentifier());
}

inline void FinishSizePrefixedAnimationBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<liquid::schemas::asset::Animation> root) {
  fbb.FinishSizePrefixed(root, AnimationIdentifier());
}

}  // namespace asset
}  // namespace schemas
}  // namespace liquid

#endif  // FLATBUFFERS_GENERATED_ANIMATION_LIQUID_SCHEMAS_ASSET_H_
